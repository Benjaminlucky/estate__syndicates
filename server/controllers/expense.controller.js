import Expense from "../models/Expense.js";
import mongoose from "mongoose";

// CREATE: Record a new expense
export const createExpense = async (req, res) => {
  try {
    const {
      title,
      amount,
      project,
      category,
      vendor,
      paymentStatus,
      paymentMethod,
      notes,
    } = req.body;

    // Use req.file.path which is the Cloudinary URL generated by your middleware
    const invoiceUrl = req.file ? req.file.path : null;

    const newExpense = new Expense({
      title,
      amount: Number(amount),
      project,
      category,
      vendor: vendor || null,
      paymentStatus,
      paymentMethod,
      notes,
      invoiceUrl,
      // Defaulting executedBy to a dummy ID if Auth isn't implemented
      executedBy: req.body.executedBy || "657a12345678901234567890",
    });

    const savedExpense = await newExpense.save();
    res.status(201).json({ success: true, expense: savedExpense });
  } catch (error) {
    res
      .status(500)
      .json({ message: "Error creating expense", error: error.message });
  }
};

// READ: Get all expenses (This feeds the frontend table)
export const getAllExpenses = async (req, res) => {
  try {
    const expenses = await Expense.find()
      .populate("project", "title")
      .populate("vendor", "name")
      .sort({ createdAt: -1 });
    res.status(200).json({ expenses });
  } catch (error) {
    res
      .status(500)
      .json({ message: "Error fetching expenses", error: error.message });
  }
};

// READ: Get expenses for a specific project
export const getProjectExpenses = async (req, res) => {
  try {
    const expenses = await Expense.find({ project: req.params.projectId })
      .populate("vendor", "name")
      .sort({ createdAt: -1 });
    res.status(200).json({ expenses });
  } catch (error) {
    res.status(500).json({
      message: "Error fetching project expenses",
      error: error.message,
    });
  }
};

// READ: Summary Stats for a project
export const getExpenseSummaryByProject = async (req, res) => {
  try {
    const { projectId } = req.params;
    const stats = await Expense.aggregate([
      { $match: { project: new mongoose.Types.ObjectId(projectId) } },
      {
        $group: {
          _id: null,
          totalAmount: { $sum: "$amount" },
          paidAmount: {
            $sum: {
              $cond: [{ $eq: ["$paymentStatus", "Paid"] }, "$amount", 0],
            },
          },
          pendingAmount: {
            $sum: {
              $cond: [{ $ne: ["$paymentStatus", "Paid"] }, "$amount", 0],
            },
          },
        },
      },
    ]);
    res
      .status(200)
      .json(stats[0] || { totalAmount: 0, paidAmount: 0, pendingAmount: 0 });
  } catch (error) {
    res
      .status(500)
      .json({ message: "Error fetching summary", error: error.message });
  }
};

// UPDATE: Change payment status
export const updateExpenseStatus = async (req, res) => {
  try {
    const updated = await Expense.findByIdAndUpdate(
      req.params.id,
      { paymentStatus: req.body.status },
      { new: true }
    );
    res.status(200).json(updated);
  } catch (error) {
    res.status(500).json({ message: "Update failed", error: error.message });
  }
};
